////////////////////////////////////////////////////////////////
//
//  Name: exec
//  GitHub repository: https://github.com/2ndSightLab/rust-service.git
//  File: src/service/exec.rs
//  Copyright: Â© 2025 2nd Sight Lab, LLC
//
//  Service execution implementation
//
//  This software, which includes components generated with the assistance of artificial
//  intelligence, is free for personal, educational, and non-profit use, provided that
//  the included copyright notice is retained in all copies or substantial portions of
//  the software. This license, however, does not grant permission for any commercial
//  use, which requires obtaining a separate commercial license from the author. The
//  software is provided "as is," without any warranty, and the author cannot be held
//  liable for any damages or claims arising from its use. By using this software,
//  all users acknowledge that any potentially uncopyrightable portions generated by
//  AI are governed by the terms of this license as part of the overall work.
//
////////////////////////////////////////////////////////////////

use log::info;
use std::{
    sync::{
        Arc,
        atomic::{AtomicBool, Ordering},
    },
    thread,
    time::Duration,
};

use crate::service::config::config_reader::load_config;
use crate::service::{ServiceError, monitoring};

pub use crate::service::config::service_config::Config;

/// Trait for service-specific configuration
pub trait ServiceConfig: Clone + Send + Sync + 'static {
    /// Loads configuration from system directories.
    ///
    /// # Errors
    /// Returns `ServiceError::Config` if configuration loading or validation fails.
    fn load() -> Result<Self, ServiceError>;
    fn service_name(&self) -> &str;
    fn log_file_path(&self) -> &str;
}

/// Action trait for extensible service functionality
pub trait Action<C: ServiceConfig>: Send + Sync {
    /// Executes the action with the given configuration.
    ///
    /// # Errors
    /// Returns `ServiceError` if the action fails to execute.
    fn execute(&self, config: &C) -> Result<(), ServiceError>;
    fn name(&self) -> &str;
}

/// Service runner that manages and executes actions
pub struct ServiceRunner<C: ServiceConfig> {
    actions: Vec<Box<dyn Action<C>>>,
}

impl<C: ServiceConfig> Default for ServiceRunner<C> {
    fn default() -> Self {
        Self::new()
    }
}

impl<C: ServiceConfig> ServiceRunner<C> {
    #[must_use]
    pub fn new() -> Self {
        Self {
            actions: Vec::new(),
        }
    }

    #[must_use]
    pub fn add_action(mut self, ACTION: Box<dyn Action<C>>) -> Self {
        self.actions.push(ACTION);
        self
    }

    /// Runs all registered actions.
    ///
    /// # Errors
    /// Returns an error if any action fails to execute.
    pub fn run(self) -> Result<(), Box<dyn std::error::Error>> {
        let CONFIG = C::load()?;

        // Check system resources before starting
        if let Ok(config) = load_config() {
            monitoring::check_resources(&config)?;
        }

        let RUNNING = Arc::new(AtomicBool::new(true));

        ctrlc::set_handler({
            let RUNNING = Arc::clone(&RUNNING);
            move || {
                RUNNING.store(false, Ordering::SeqCst);
            }
        })?;

        info!("Starting {}", CONFIG.service_name());

        // Start all actions - they handle their own execution patterns
        for action in &self.actions {
            if let Err(e) = action.execute(&CONFIG) {
                log::error!("Action failed: {e}");
                return Err(e.into());
            }
        }

        // Wait for shutdown signal
        while RUNNING.load(Ordering::SeqCst) {
            thread::sleep(Duration::from_millis(100));
        }

        info!("Service shutting down gracefully");
        Ok(())
    }
}

// Keep backward compatibility
impl ServiceConfig for Config {
    fn load() -> Result<Self, ServiceError> {
        load_config()
    }

    fn service_name(&self) -> &str {
        &self.SERVICE_NAME
    }

    fn log_file_path(&self) -> &str {
        &self.LOG_FILE_PATH
    }
}
