////////////////////////////////////////////////////////////////
//
//  Name: config
//  GitHub repository: https://github.com/2ndSightLab/rust-service.git
//  File: src/service/config.rs
//  Copyright: Â© 2025 2nd Sight Lab, LLC
//
//  Service configuration structure and validation
//
//  This software, which includes components generated with the assistance of artificial
//  intelligence, is free for personal, educational, and non-profit use, provided that
//  the included copyright notice is retained in all copies or substantial portions of
//  the software. This license, however, does not grant permission for any commercial
//  use, which requires obtaining a separate commercial license from the author. The
//  software is provided "as is," without any warranty, and the author cannot be held
//  liable for any damages or claims arising from its use. By using this software,
//  all users acknowledge that any potentially uncopyrightable portions generated by
//  AI are governed by the terms of this license as part of the overall work.
//
////////////////////////////////////////////////////////////////

use crate::security::validation::{sanitize_message, validate_config_field};
use crate::service::service_error::ServiceError;
use serde::Deserialize;
use std::fs;

#[must_use]
pub const fn get_config_file_name() -> &'static str {
    "service.toml"
}

#[derive(Debug, Deserialize, Clone)]
#[allow(non_snake_case)]
pub struct Config {
    pub LOG_FILE_PATH: String,
    pub INSTALL_DIR: String,
    pub SERVICE_NAME: String,
    pub MEMORY_THRESHOLD: u32,
    pub DISK_THRESHOLD: u32,
    pub MIN_FD_LIMIT: u64,
    pub MAX_SERVICE_NAME_LEN: usize,
    pub MAX_LOG_PATH_LEN: usize,
    pub MIN_LOG_INTERVAL_MS: u64,
    pub MAX_LOG_FILE_SIZE: u64,
    pub MAX_THRESHOLD_PERCENT: u32,
    pub MAX_FD_LIMIT: u64,
    pub MAX_CONFIG_FIELD_LEN: usize,
}

/// Validates all service configuration fields.
///
/// # Errors
/// Returns `ServiceError` if any configuration field is invalid.
pub fn validate_all_config_fields(config: &Config) -> Result<(), ServiceError> {
    let _sanitized_name = sanitize_message(&config.SERVICE_NAME, config.MAX_SERVICE_NAME_LEN)?;

    validate_config_field(
        &config.SERVICE_NAME.len(),
        &1,
        &config.MAX_SERVICE_NAME_LEN,
        "service_name",
    )?;
    validate_config_field(
        &config.LOG_FILE_PATH.len(),
        &1,
        &config.MAX_LOG_PATH_LEN,
        "log_file_path",
    )?;
    validate_config_field(
        &config.INSTALL_DIR.len(),
        &1,
        &config.MAX_LOG_PATH_LEN,
        "install_dir",
    )?;
    validate_config_field(
        &config.MEMORY_THRESHOLD,
        &1,
        &config.MAX_THRESHOLD_PERCENT,
        "memory_threshold",
    )?;
    validate_config_field(
        &config.DISK_THRESHOLD,
        &1,
        &config.MAX_THRESHOLD_PERCENT,
        "disk_threshold",
    )?;
    validate_config_field(
        &config.MIN_FD_LIMIT,
        &1,
        &config.MAX_FD_LIMIT,
        "min_fd_limit",
    )?;
    validate_config_field(
        &config.MAX_SERVICE_NAME_LEN,
        &1,
        &config.MAX_CONFIG_FIELD_LEN,
        "max_service_name_len",
    )?;
    validate_config_field(
        &config.MAX_LOG_PATH_LEN,
        &1,
        &config.MAX_CONFIG_FIELD_LEN,
        "max_log_path_len",
    )?;
    Ok(())
}

/// Loads configuration from executable directory with validation against secure paths
///
/// # Errors
/// Returns `ServiceError` if configuration cannot be loaded or is invalid.
pub fn load_secure_config() -> Result<Config, ServiceError> {
    // Validate paths against secure directories: "/var/log", "/opt"
    let EXE_PATH = std::env::current_exe()
        .map_err(|e| ServiceError::Config(format!("Cannot determine executable path: {e}")))?;

    let EXE_DIR = EXE_PATH
        .parent()
        .ok_or_else(|| ServiceError::Config("Cannot determine executable directory".to_string()))?;

    let CONFIG_PATH = EXE_DIR.join("service.toml");

    if !CONFIG_PATH.exists() {
        return Err(ServiceError::Config(
            "No valid config file found".to_string(),
        ));
    }

    // Open file first to get file descriptor
    let FILE = fs::File::open(&CONFIG_PATH).map_err(|e| {
        ServiceError::Config(format!(
            "Failed to open config file {}: {e}",
            CONFIG_PATH.display()
        ))
    })?;

    // Use file descriptor for metadata check to prevent race conditions
    let _metadata = FILE
        .metadata()
        .map_err(|e| ServiceError::Config(format!("Cannot read config file metadata: {e}")))?;

    let CONTENT = fs::read_to_string(&CONFIG_PATH)
        .map_err(|e| ServiceError::Config(format!("Failed to read config file: {e}")))?;

    let CONFIG: Config =
        toml::from_str(&CONTENT).map_err(|e| ServiceError::Config(format!("Invalid TOML: {e}")))?;

    validate_all_config_fields(&CONFIG)?;
    Ok(CONFIG)
}
