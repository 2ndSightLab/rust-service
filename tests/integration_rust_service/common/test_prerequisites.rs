////////////////////////////////////////////////////////////////
//
//  Name: test_prerequisites
//  GitHub repository: https://github.com/2ndSightLab/rust-service.git
//  File: tests/integration_rust_service/common/test_prerequisites.rs
//  Copyright: Â© 2025 2nd Sight Lab, LLC
//
//  Test file for test_prerequisites
//
//  This software, which includes components generated with the assistance of artificial
//  intelligence, is free for personal, educational, and non-profit use, provided that
//  the included copyright notice is retained in all copies or substantial portions of
//  the software. This license, however, does not grant permission for any commercial
//  use, which requires obtaining a separate commercial license from the author. The
//  software is provided "as is," without any warranty, and the author cannot be held
//  liable for any damages or claims arising from its use. By using this software,
//  all users acknowledge that any potentially uncopyrightable portions generated by
//  AI are governed by the terms of this license as part of the overall work.
//
////////////////////////////////////////////////////////////////

use rust_service::service::load_config;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::Path;

pub struct TestPaths {
    pub binary: String,
    pub config: String,
    pub action_config: String,
}

pub fn get_test_paths() -> Result<TestPaths, String> {
    // Use application's config loading function
    let CONFIG = load_config().map_err(|e| format!("Failed to load config: {e}"))?;

    // For library projects, use executable directory for configs
    let EXE_PATH =
        std::env::current_exe().map_err(|e| format!("Cannot determine executable path: {e}"))?;
    let EXE_DIR = EXE_PATH
        .parent()
        .ok_or_else(|| "Cannot determine executable directory".to_string())?;

    let LOCAL_CONFIG_DIR = EXE_DIR
        .to_str()
        .ok_or_else(|| "Invalid executable directory path".to_string())?;

    // Extract paths from loaded config
    let INSTALL_DIR = &CONFIG.INSTALL_DIR;

    // Check if debug installation exists, otherwise use release
    let DEBUG_BINARY = format!("{INSTALL_DIR}-debug/test-rust-service");
    let DEBUG_CONFIG = format!("{LOCAL_CONFIG_DIR}/service.toml");
    let DEBUG_ACTION_CONFIG = format!("{LOCAL_CONFIG_DIR}/action.toml");

    let (BINARY_PATH, CONFIG_PATH, ACTION_CONFIG_PATH) = if Path::new(&DEBUG_BINARY).exists() {
        (DEBUG_BINARY, DEBUG_CONFIG, DEBUG_ACTION_CONFIG)
    } else {
        (
            format!("{INSTALL_DIR}/test-rust-service"),
            format!("{LOCAL_CONFIG_DIR}/service.toml"),
            format!("{LOCAL_CONFIG_DIR}/action.toml"),
        )
    };

    Ok(TestPaths {
        binary: BINARY_PATH,
        config: CONFIG_PATH,
        action_config: ACTION_CONFIG_PATH,
    })
}

pub fn check_debug_installation() -> Result<(), String> {
    let PATHS = get_test_paths()?;

    // Check if binary exists
    if fs::metadata(&PATHS.binary).is_err() {
        return Err(format!(
            "Binary not found at {}. Run './actions/test.sh' to install it.",
            PATHS.binary
        ));
    }

    // Check if config exists
    if fs::metadata(&PATHS.config).is_err() {
        return Err(format!(
            "Config not found at {}. Run './actions/test.sh' to install it.",
            PATHS.config
        ));
    }

    // Check if binary is executable
    let METADATA = fs::metadata(&PATHS.binary)
        .map_err(|e| format!("Cannot access binary {}: {e}", PATHS.binary))?;

    let PERMISSIONS = METADATA.permissions();
    if PERMISSIONS.mode() & 0o111 == 0 {
        return Err(format!("Binary {} is not executable", PATHS.binary));
    }

    Ok(())
}

#[test]
fn test_debug_installation_exists() {
    if let Err(msg) = check_debug_installation() {
        panic!("Integration test prerequisites not met: {msg}");
    }
}
